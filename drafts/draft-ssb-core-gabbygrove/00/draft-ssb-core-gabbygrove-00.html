<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>GabbyGrove (CBOR-based Feed Format)</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Gabby Grove">
<link href="#rfc.section.2" rel="Chapter" title="2 Rationale">
<link href="#rfc.section.2.1" rel="Chapter" title="2.1 Keeping the timestamp">
<link href="#rfc.section.2.2" rel="Chapter" title="2.2 Keeping the author field">
<link href="#rfc.section.2.3" rel="Chapter" title="2.3 Only encoding the content">
<link href="#rfc.section.3" rel="Chapter" title="3 Definitions for SSB">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Event">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Transfer">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Cipherlinks">
<link href="#rfc.section.3.3.1" rel="Chapter" title="3.3.1 Cross references">
<link href="#rfc.section.3.4" rel="Chapter" title="3.4 Signing capability">
<link href="#rfc.section.4" rel="Chapter" title="4 CBOR">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Basics">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Canonical encoding">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Extensibility">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Examples">
<link href="#rfc.section.4.4.1" rel="Chapter" title="4.4.1 Key Pair">
<link href="#rfc.section.4.4.2" rel="Chapter" title="4.4.2 Event">
<link href="#rfc.section.4.4.3" rel="Chapter" title="4.4.3 Transfer">
<link href="#rfc.section.5" rel="Chapter" title="5 Code and roll out">
<link href="#rfc.section.6" rel="Chapter" title="6 Remarks">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Alternative Encodings">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Deletion requests">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Size benefits">
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 How long lived this will be?">
<link href="#rfc.section.7" rel="Chapter" title="7 Addressed comments from ProtoChain">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Event">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 &#8220;Content Type&#8221;">
<link href="#rfc.section.8" rel="Chapter" title="8 Comments addressed since the first &#8220;off-chain content&#8221; proposal">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 incrementing on a broken format">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 The use of MUXRPC specific features for transmission/replication">
<link href="#rfc.references" rel="Chapter" title="9 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.22.3 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="cryptix, ." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ssb-core-gabbygrove-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-08-06" />
  <meta name="dct.abstract" content="This document defines a new binary format for append-only feeds as used by Secure-Scuttlebutt.  That is, it defines the bytes that are used for computing the cryptographic signatures and hashes that make up a feed in this format.  It strives to do two things: Be easier to implement compared to the current scheme. Hence, it uses CBOR  to encode the logical values that describe each entry.  Secondly, the feed entry only references content by hash to enable content deletion without breaking verification of the feed." />
  <meta name="description" content="This document defines a new binary format for append-only feeds as used by Secure-Scuttlebutt.  That is, it defines the bytes that are used for computing the cryptographic signatures and hashes that make up a feed in this format.  It strives to do two things: Be easier to implement compared to the current scheme. Hence, it uses CBOR  to encode the logical values that describe each entry.  Secondly, the feed entry only references content by hash to enable content deletion without breaking verification of the feed." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Secure Scuttlebutt Working Group</td>
<td class="right">. cryptix</td>
</tr>
<tr>
<td class="left">SSB-Draft</td>
<td class="right">SSBC</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">August 06, 2019</td>
</tr>
<tr>
<td class="left">Expires: February 7, 2020</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">GabbyGrove (CBOR-based Feed Format)<br />
  <span class="filename">draft-ssb-core-gabbygrove-00</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document defines a new binary format for append-only feeds as used by Secure-Scuttlebutt.  That is, it defines the bytes that are used for computing the cryptographic signatures and hashes that make up a feed in this format.  It strives to do two things: Be easier to implement compared to the current scheme. Hence, it uses <a href="https://cbor.io">CBOR</a> <a href="#RFC7049" class="xref">[RFC7049]</a> to encode the logical values that describe each entry.  Secondly, the feed entry only references content by hash to enable content deletion without breaking verification of the feed.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>SSB-Drafts are working documents of the Secure Scuttlebutt community.  Note that other groups may also distribute working documents as SSB-Drafts.</p>
<p>SSB-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use SSB-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This SSB-Draft will expire on February 7, 2020.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 SSB Council and the persons identified as the document authors.  All rights reserved.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Gabby Grove</a>
</li>
<li>2.   <a href="#rfc.section.2">Rationale</a>
</li>
<ul><li>2.1.   <a href="#rfc.section.2.1">Keeping the timestamp</a>
</li>
<li>2.2.   <a href="#rfc.section.2.2">Keeping the author field</a>
</li>
<li>2.3.   <a href="#rfc.section.2.3">Only encoding the content</a>
</li>
</ul><li>3.   <a href="#rfc.section.3">Definitions for SSB</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Event</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Transfer</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Cipherlinks</a>
</li>
<ul><li>3.3.1.   <a href="#rfc.section.3.3.1">Cross references</a>
</li>
</ul><li>3.4.   <a href="#rfc.section.3.4">Signing capability</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">CBOR</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Basics</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Canonical encoding</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Extensibility</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Examples</a>
</li>
<ul><li>4.4.1.   <a href="#rfc.section.4.4.1">Key Pair</a>
</li>
<li>4.4.2.   <a href="#rfc.section.4.4.2">Event</a>
</li>
<li>4.4.3.   <a href="#rfc.section.4.4.3">Transfer</a>
</li>
</ul></ul><li>5.   <a href="#rfc.section.5">Code and roll out</a>
</li>
<li>6.   <a href="#rfc.section.6">Remarks</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Alternative Encodings</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Deletion requests</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Size benefits</a>
</li>
<li>6.4.   <a href="#rfc.section.6.4">How long lived this will be?</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Addressed comments from ProtoChain</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Event</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">&#8220;Content Type&#8221;</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Comments addressed since the first &#8220;off-chain content&#8221; proposal</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">incrementing on a broken format</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">The use of MUXRPC specific features for transmission/replication</a>
</li>
</ul><li>9.   <a href="#rfc.references">Informative References</a>
</li>
<li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#gabby-grove" id="gabby-grove">Gabby Grove</a>
</h1>
<p id="rfc.section.1.p.1">This is the revised version of <a href="ssb://%3ATKLKIHdM+beamr1dqoO2Jd6BC7oW5zj0ygLvmDsEc=.sha256">the ProtoChain proposal</a>.  The main difference to <em>ProtoChain</em> is that <em>Gabby Grove</em> uses CBOR instead of Protocol Buffers.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#rationale" id="rationale">Rationale</a>
</h1>
<p id="rfc.section.2.p.1">While this is would introduce new ways of doing things, like requiring CBOR for encoding and supporting multiple feed formats, it also makes concessions to how things are currently. In a sense this proposal should be seen as an overhaul of the current scheme, only adding off-chain capabilities. Let me elaborate on two of them which cater to this point specifically:</p>
<h1 id="rfc.section.2.1">
<a href="#rfc.section.2.1">2.1.</a> <a href="#keeping-the-timestamp" id="keeping-the-timestamp">Keeping the timestamp</a>
</h1>
<p id="rfc.section.2.1.p.1">In principle, the timestamp is an application concern. Some types of messages could omit the timestamp and it could be considered <em>cleaner</em> to move them up into the content of messages which want to supply them. We recognize however that it would stir up problems for existing applications and this is something we are not interested in.</p>
<h1 id="rfc.section.2.2">
<a href="#rfc.section.2.2">2.2.</a> <a href="#keeping-the-author-field" id="keeping-the-author-field">Keeping the author field</a>
</h1>
<p id="rfc.section.2.2.p.1">A similar argument could be made for the author. In the current design the author never changes over the lifetime of a feed, so why have it on each and every entry of a feed? Especially if you replicate one feed at a time it seems wasteful, since the author is already known.</p>
<p><a href="ssb://@EMovhfIrFk4NihAKnRNhrfRaqIhBv1Wj8pTxJNgvCCY=.ed25519">Dominic Tarr</a> made a security argument <a href="ssb://%1AsqTRxdVrbfypC69W7uWbMClQteNNnnl3ohzbpu3Xw=.sha256">here</a>. It should always be known which key-pair created a signature and thus having it reduces ambiguity and possible backdoors.</p>
<h1 id="rfc.section.2.3">
<a href="#rfc.section.2.3">2.3.</a> <a href="#only-encoding-the-content" id="only-encoding-the-content">Only encoding the content</a>
</h1>
<p id="rfc.section.2.3.p.1">At first, this format would only encode the header fields of a message (subsequently called <samp>event</samp>) as CBOR, leaving the author of a feed to encode their content as they see fit.  An encoding enumeration field on the <samp>event</samp> sets one of a set of known values for arbitrary data (<samp>0</samp>), JSON (<samp>1</samp>) and CBOR (<samp>2</samp>).</p>
<p id="rfc.section.2.3.p.2">Since we don&#8217;t want to cause problems for applications, we suggest keeping the <samp>content</samp> portion in JSON <a href="#RFC8259" class="xref">[RFC8259]</a> for now.  This should allow for events to be mapped to full JSON objects which look just like regular, legacy messages so that they can be consumed by applications with minimal changes.  CBOR <em>should</em> be good at converting it&#8217;s values to JSON for integration and backwards compatibility to other parts of the SSB stack.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#definitions-for-ssb" id="definitions-for-ssb">Definitions for SSB</a>
</h1>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#event" id="event">Event</a>
</h1>
<p id="rfc.section.3.1.p.1">A single entry on an feed with this format is called an event (formerly also known as Message).  It contains a fixed number of fields:</p>
<p></p>

<ul>
<li>A cipherlink to the <samp>previous</samp> one, null only on the first entry.</li>
<li>The ed25519 public key of the <samp>author</samp>, also encoded as a cipherlink.</li>
<li>The <samp>sequence</samp> number of the entry as an unsigned integer. Increasing by 1 each entry, starting with 1.</li>
<li>An unsigned integer describing a <samp>timestamp</samp>. UNIX epoch timestamp (number of seconds since 1970-01-01).</li>
<li>
<samp>content</samp>: an array of three fields: <ul>
<li>
<samp>hash</samp> as a cipherlink</li>
<li>
<samp>size</samp> as a uint16, increasing the maximum content size to 64k.</li>
<li>
<samp>encoding</samp> enumeration of three possible values.</li>
</ul>
</li>
</ul>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#transfer" id="transfer">Transfer</a>
</h1>
<p id="rfc.section.3.2.p.1">The next needed structure is <samp>transfer</samp>. It consists of three byte arrays:</p>
<p></p>

<ul>
<li>The encoded bytes of an <samp>event</samp>, here called <samp>eventData</samp>.</li>
<li>
<samp>signature</samp>: 64 bytes, to be verified against the <samp>author</samp>s public key from the event.</li>
<li>the optional <samp>content</samp>: a maximum of 64k bytes.</li>
</ul>
<p id="rfc.section.3.2.p.3">To validate the <samp>transfer</samp>, the receiver takes the byte strings <samp>eventData</samp> and <samp>signature</samp> and passes them to the cryptographic function that does the validation.  The only supported functions of this format is, edwards25519 as defined in <a href="#RFC8032" class="xref">[RFC8032]</a>, also known as Ed25519 from the <a href="https://nacl.cr.yp.to/">Networking and Cryptography library (NaCL)</a>.</p>
<p id="rfc.section.3.2.p.4">If <samp>content</samp> is present, hashing it needs to compute the same hash as stated by the <samp>content.hash</samp> field on the event.  To omit the <samp>content</samp>, it needs to be set to <samp>null</samp> (primitive 22 or <samp>0xf6</samp> in CBOR), so that the array the field is contained in has the same size in both cases.</p>
<p id="rfc.section.3.2.p.5">The hash of a signed event (and the <samp>previous</samp> field of the next event) is the SHA256 of <samp>eventData</samp> and <samp>signature</samp> bytes concatenated.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#cipherlinks" id="cipherlinks">Cipherlinks</a>
</h1>
<p id="rfc.section.3.3.p.1">The hashes and public key references are not base64 encoded readable ASCII text strings but are binary encoded.</p>
<p id="rfc.section.3.3.p.2">In this first version we don&#8217;t plan to support many formats, which is why we don&#8217;t use something like <a href="https://github.com/multiformats/multihash">IPFS Multihash</a>, which supports every hash function under the sun.</p>
<p id="rfc.section.3.3.p.3">Currently there are these different reference types:</p>
<p></p>

<ul>
<li>
<samp>0x01</samp>: references to gabby grove formatted feeds (ED25519 Public Key, 32bytes of data)</li>
<li>
<samp>0x02</samp>: gabby grove signed event hashes (such as <samp>previous</samp>), using SHA256 (32bytes of data)</li>
<li>
<samp>0x03</samp>: <samp>content.hash</samp> also using SHA256 (32bytes of data)</li>
<li>
<samp>0x04</samp>: &#8220;SSB v1&#8221;, legacy / old feed reference (ED25519 Public Key, 32bytes of data)</li>
<li>
<samp>0x05</samp>: SHA256 message hashes as used by legacy ssb</li>
<li>
<samp>0x06</samp>: SHA256 binary blob hashes as used by legacy ssb</li>
</ul>
<p id="rfc.section.3.3.p.5">Only 1, 2 and 3 are used on gabby grove event fields.  4 to 6 are intended to encode cipherlinks in CBOR encoded content when referencing feeds in the legacy format.  I&#8217;m relatively certain and hopeful this will be revised and extended but it feels like a good starting point.  They all should be convertible to and from the base64 encoded ASCII references we currently use in JSON.  We add one byte as prefix to those bytes, making all references 33bytes long, for now.</p>
<h1 id="rfc.section.3.3.1">
<a href="#rfc.section.3.3.1">3.3.1.</a> <a href="#cross-references" id="cross-references">Cross references</a>
</h1>
<p id="rfc.section.3.3.1.p.1">Up until now SSB only had to deal with <samp>.ed25519</samp> and <samp>.sha256</samp> to identify a whole feed and individual entries respectively. Although I&#8217;d like to avoid a registry of known suffixes, my <a href="ssb://%t5mSAGJZEWus/HO+180M9SSsn5irHg/LVQTVqODFS9I=.sha256">initial thoughts</a> on how to do <em>decent</em> subjective name-spaces for identifier and networks are still very vague. For the meantime, this document proposes the <samp>.ggfeed-v1</samp> suffix as a default feed reference and <samp>.ggmsg-v1</samp> for messages.</p>
<p id="rfc.section.3.3.1.p.2">The author also briefly looked into <a href="https://docs.ipfs.io/guides/concepts/cid/">IPFS Content Identifiers (CID)s</a> and <a href="https://w3c-ccg.github.io/did-spec/">Decentralized Identifiers (DIDs)</a> but discarded them since it leaves the scope of this specification. It&#8217;s only important that we clearly discern and define type and data of these identifiers so that we can convert to and from them down the road.</p>
<h1 id="rfc.section.3.4">
<a href="#rfc.section.3.4">3.4.</a> <a href="#signing-capability" id="signing-capability">Signing capability</a>
</h1>
<p id="rfc.section.3.4.p.1">The existing legacy format has an <a href="https://github.com/ssbc/ssb-keys#signobjkeys-hmac_key-obj">optional HMAC signing capability</a>. When enabled, a hashed message authentication code (<a href="https://en.wikipedia.org/wiki/HMAC">HMAC</a>) is signed instead of the the message (the <samp>event</samp> bytes inside a <samp>transfer</samp> in our case). For this a (usually secret among the users of the network) key is needed. Without this key for the HMAC function, the receiver can&#8217;t validate the signature. Because messages are still communicated as clear text, this mode doesn&#8217;t add any confidentiality, which the needed key might imply. Therefore this mode is primarily usefull for splitting networks of feeds, like for testing purposes.</p>
<p id="rfc.section.3.4.p.2">Currently this format uses exactly the same scheme as the legacy format for portability reasons. The used HMAC function is NaCLs <samp>crypto_auth</samp>, defined <a href="https://nacl.cr.yp.to/auth.html">here</a>.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#cbor" id="cbor">CBOR</a>
</h1>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#basics" id="basics">Basics</a>
</h1>
<p id="rfc.section.4.1.p.1">If you never worked with CBOR, I suggest checking out it&#8217;s <a href="https://cbor.io">website</a> and the definitions in <a href="#RFC7049" class="xref">[RFC7049]</a>). Similar to JSON it is a <em>self describing</em> format. Which means, bytes of it can be translated to logical, typed values without the need for a schema definition.</p>
<p id="rfc.section.4.1.p.2">The <a href="https://github.com/cabo/cbor-diag">cbor-diag utilities</a> (or the <a href="https://cbor.me">the playground at cbor.me</a> with the same features) can help a lot to see how it works. With it, we can translate between encoded bytes and the diagnostic notation (defined in section 6 of CBORs RFC).  Roughly speaking we can use JSON-like literals as diagnostic input for <samp>diag2pretty.rb</samp> (or the left side of the playground):</p>
<pre>
{
  "type": "test",
  "count": 123,
  "true": false,
  "link": null
}
</pre>
<p id="rfc.section.4.1.p.3">which outputs a hexadecimal, indented and commented representation with type annotations:</p>
<pre>
A4               # map(4)
   64            # text(4)
      74797065   # "type"
   64            # text(4)
      74657374   # "test"
   65            # text(5)
      636F756E74 # "count"
   18 7B         # unsigned(123)
   64            # text(4)
      74727565   # "true"
   F4            # primitive(20)
   64            # text(4)
      6C696E6B   # "link"
   F6            # primitive(22)
</pre>
<p id="rfc.section.4.1.p.4">The comments (everything right of the <samp>#</samp> character) tell us the types and values again. The first line says &#8220;0xA4 means the following is a map with 4 entries&#8221;.  Maps are key-value pairs, so we get three pairs of first the name (or key) of the pair and then the value.  Next to signed and unsigned number types it also has predefined primitives for <samp>true</samp>, <samp>false</samp> and <samp>null</samp>.  Notice that the keys are also typed (<em>text of len N</em>).</p>
<p id="rfc.section.4.1.p.5">Let&#8217;s compare the previous example to an array of the same values, without the keys:</p>
<pre>
["test", 123, false, null]
</pre>
<p id="rfc.section.4.1.p.6">results in</p>
<pre>
84             # array(4)
   64          # text(4)
      74657374 # "test"
   18 7B       # unsigned(123)
   F4          # primitive(20)
   F6          # primitive(22)
</pre>
<p id="rfc.section.4.1.p.7">This results in 10 encoded bytes. The map example needs 31, in comparison.</p>
<p id="rfc.section.4.1.p.8">Encoding the same well-defined objects as maps over and over again comes with a lot of overhead and redundant description of the field names.</p>
<p id="rfc.section.4.1.p.9">This is also why the previous attempt to define a new feed format used Protocol Buffers. A self-describing format isn&#8217;t inherently useful since the fields of an <samp>event</samp> don&#8217;t change.  As shown above, the size overhead of encoding structures as maps can be mitigated by encoding them as arrays instead.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#canonical-encoding" id="canonical-encoding">Canonical encoding</a>
</h1>
<p id="rfc.section.4.2.p.1">We <em>could</em> define the first field of a <samp>transfer</samp> as an <samp>event</samp> itself instead of opaque byte strings but canonical encoding on this level of the protocol is seen as optional.  Meaning: if the implementation can re-produce the same <samp>eventData</samp> from an stored <samp>Event</samp>, go ahead.  Butt be wary, diverging one bit from the original <samp>eventData</samp> means that signature verification and hash comparison will fail.  Over all this seems like an potentially instable and divergent way of exchanging feeds, producing incorrect references as heads of a feed if implementations incorrectly consume them.</p>
<p id="rfc.section.4.2.p.2">However, as an experiment, implementers are advised to use the canonical CBOR suggestions defined in <a href="https://tools.ietf.org/html/rfc7049#section-3.9">Section 3.9 of CBORs RFC</a>.  Since we only use bytes, integers and tags for our structures we can ignore the suggestions for map keys and floats.</p>
<p id="rfc.section.4.2.p.3">Potentially, a canonical encoding would allow for skipping certain fields on the transport layer.  <samp>author</samp>, <samp>sequence</samp> and even <samp>previous</samp> could be filled in by the receiver themselves to produce the full <samp>eventData</samp>.</p>
<p id="rfc.section.4.2.p.4">It would also free implementors on the question of how to store events.  It&#8217;s unclear to the author if this amounts to a worth-while endeavor compared to just storing the bytes of the <samp>transfer</samp>.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#extensibility" id="extensibility">Extensibility</a>
</h1>
<p id="rfc.section.4.3.p.1">CBOR allows for augmenting the types of it&#8217;s values with an additional numeric tag. These are hints for the de- and encoders to treat some type of values differently. See <a href="https://tools.ietf.org/html/rfc7049#section-2.4">Section 2.4 of CBORs RFC</a> for more. <a href="https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml#tags">A list of defined CBOR Tags</a> is maintained by the IANA.</p>
<p id="rfc.section.4.3.p.2">This kind of extensibility through type tags seems useful for SSB, especially if we ever change away from JSON as the content encoding.  With it, we can explicitly mark cipherlinks as such, for instance. I took the liberty to take one of the <em>first come first served</em> numbers for the cipherlinks above, it&#8217;s 1050.</p>
<p><a href="https://tools.ietf.org/html/rfc7049#section-2.4.4.1">Section 2.4.4.1 of the CBOR RFC</a> also defines tag number 24 to delay decoding of embedded cbor values (like the <samp>event</samp> in the <samp>transfer</samp>). Depending on how flexible the used CBOR libarary is, this might help input validation but since each field of an <samp>event</samp> has to be checked in context of the feed for append validation, this feature was not applied to this version of the format.</p>
<p id="rfc.section.4.3.p.4">Another option would be to explicitly tag the whole <samp>transfer</samp>, which is otherwise <em>just</em> an array with three opaque byte string entries, and state how the signature was computed by the author&#8217;s key-pair referenced inside the <samp>event</samp>. And also define the role of the actual <samp>content</samp> bytes in relation to the <samp>content</samp> field in the <samp>event</samp>.</p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#examples" id="examples">Examples</a>
</h1>
<p id="rfc.section.4.4.p.1">As a concrete example of all the above combined, here are some actual structures of this format encoded as CBOR.</p>
<h1 id="rfc.section.4.4.1">
<a href="#rfc.section.4.4.1">4.4.1.</a> <a href="#key-pair" id="key-pair">Key Pair</a>
</h1>
<p id="rfc.section.4.4.1.p.1">of the ED25519 key-pair that was seeded with <samp>dead</samp> repeated 8 times, which is a poor choice for an actual key-pair but gives us deterministic test data. I tested sodium-native on javascript and ed25519 for Go by agl and x/crypto and they all gave me these public key bytes as a hexdump:</p>
<pre>
00000000  AED3DAB65CE9E0D6C50D46FCEFFB5522  |....\.....F...U"|
00000010  96ED21B6E0B537A6A0184575CE8F5CBD  |..!...7...Eu..\.|
</pre>
<h1 id="rfc.section.4.4.2">
<a href="#rfc.section.4.4.2">4.4.2.</a> <a href="#event-1" id="event-1">Event</a>
</h1>
<p id="rfc.section.4.4.2.p.1">These are the first two messages of a feed authored by the keypair above.</p>
<pre>
 1:85                                      # array(5)
 2:   F6                                   # primitive(22)
 3:   D9 041A                              # tag(1050)
 4:      58 21                             # bytes(33)
 5:         01
 6:         AED3DAB65CE9E0D6C50D46FCEFFB5522
 7:         96ED21B6E0B537A6A0184575CE8F5CBD
 8:   01                                   # unsigned(1)
 9:   1A 5D3F8880                          # unsigned(1564444800)
10:   83                                   # array(3)
11:      01                                # unsigned(1)
12:      07                                # unsigned(7)
13:      D9 041A                           # tag(1050)
14:         58 21                          # bytes(33)
15:            03
16:            E806ECF2B7C37FB06DC198A9B905BE64
17:            EE3FDB8237EF80D316ACB7C85BBF5F02
</pre>
<p id="rfc.section.4.4.2.p.2">Let&#8217;s discuss line by line what this means:</p>
<p></p>

<ol>
<li>The first line, <samp>85 # array(5)</samp>, tells us <samp>0x85</samp> is the first byte and means &#8220;this is an array with five elements&#8221;. What follows are the five fields that were defined in Section 3.1 of this document: <samp>previous</samp>, <samp>author</samp>, <samp>sequence</samp>, <samp>timestamp</samp> and <samp>content</samp>.</li>
<li>
<samp>0xF6</samp> is the first value of this array. The <samp>primitive(22)</samp> is a special CBOR value, signaling <samp>null</samp>. So the <samp>previous</samp> hash is <samp>null</samp>, which is fine for the first message.</li>
<li>The three bytes (<samp>0xD904A1</samp>) mean <samp>tag(1050)</samp>. This is CBORs optional tagging feature, introduced in Section 4.3 of this document. It tell&#8217;s the decoder &#8220;the following values is tagged with the number 1050&#8221;. This value describes cipherlinks, defined in Section 3.3 of this document.</li>
<li>The following line with the two bytes <samp>0x5821</samp> just tells the decoder &#8220;the following are 33 bytes&#8221; and can be taking literally in value without any modification.</li>
<li>These are the 33 bytes of a cipherlink. Since this cipherlink starts with a <samp>0x01</samp>, it is the public key of an author.</li>
<li>This is the first half of the authors public key, broken in two lines of 16bytes each. (This is only to conform with the 72 character limit of text only output of this document.)</li>
<li>This is the 2nd half of the authors public key.</li>
<li>The next line is the third element of the array: the <samp>sequence</samp> number encoded as an unsigned integer, as the comment tells us.</li>
<li>The fourth element is the <samp>timestamp</samp> also encoded as an unsigned integer. As a starting timestamp I picked 2019-07-30, which translates to 1564444800 seconds as a Unix epoch timestamp.</li>
<li>The fifth element is the <samp>content</samp> object, which itself is encoded as an array of 3 items (<samp>encoding</samp>, <samp>size</samp> and <samp>hash</samp>)</li>
<li>The number 1 means the content was encoded as <samp>json</samp> (See Section 2.3).</li>
<li>This is the content&#8217;s <samp>size</samp>, in bytes also as an unsigned integer. Meaning, this content is 7 bytes long.</li>
<li>Finally, we have a cipherlink again.</li>
<li>It&#8217;s 33 bytes long</li>
<li>It starts with 03 which means, it&#8217;s a content hash. (See Section 3.3)</li>
<li>The following two lines are the hash function output. Where this comes from will be shown in the next section.</li>
</ol>
<p id="rfc.section.4.4.2.p.4">Here is the next message:</p>
<pre>
85                                      # array(5)
   D9 041A                              # tag(1050)
      58 21                             # bytes(33)
         02
         0113F4DD8C981D1D87BC7F46CF86E8E7
         B0FB774F839930DD38D6A13F69D9693D
   D9 041A                              # tag(1050)
      58 21                             # bytes(33)
         01
         AED3DAB65CE9E0D6C50D46FCEFFB5522
         96ED21B6E0B537A6A0184575CE8F5CBD
   02                                   # unsigned(2)
   1A 5D3F8881                          # unsigned(1564444801)
   83                                   # array(3)
      01                                # unsigned(1)
      16                                # unsigned(22)
      D9 041A                           # tag(1050)
         58 21                          # bytes(33)
            03
            95CCA4FA7B24ABC6049683E716292B00
            C49509BE147AA024C06286BD9B7DBDA8

</pre>
<p id="rfc.section.4.4.2.p.5">If you compare this to the above you should see some similarities. Instead of <samp>0xf6</samp> as the first element as the array we now have <samp>0xD0491A5821</samp>. We have seen this sequence twice above already: It&#8217;s a cipherlink with 33 bytes of data. Instead of starting with byte <samp>0x01</samp> or <samp>0x03</samp>, this starts with <samp>0x02</samp> which means, it&#8217;s a hash of a signed event.</p>
<h1 id="rfc.section.4.4.3">
<a href="#rfc.section.4.4.3">4.4.3.</a> <a href="#transfer-1" id="transfer-1">Transfer</a>
</h1>
<p id="rfc.section.4.4.3.p.1">Here is the transfer object for the first event:</p>
<pre>
83                                      # array(3)
   58 57                                # bytes(87)
      85F6D9041A582101AED3DAB65CE9E0D6C50D46FCEFFB552296ED21B6E
      0B537A6A0184575CE8F5CBD011A5D3F8880830107D9041A582103E806
      ECF2B7C37FB06DC198A9B905BE64EE3FDB8237EF80D316ACB7C85BBF5
      F02
   58 40                                # bytes(64)
      91F1B00C37285FC517D4C87FDA951A6BC38AEE7E7DCB8E3CE538289C5
      CBA0E93A5734BD6853D11FA29DDF0BFE5BC4B5049EF4681CAA1BAA355
      CD2FFC94191104
   47                                   # bytes(7)
      666F6F2E626F78                    # "foo.box"
</pre>
<p id="rfc.section.4.4.3.p.2">Similar to the above, we have an array with 3 elements, each in turn being a byte string of varying size.  The first one is the <samp>eventData</samp>, the second one is the <samp>signature</samp> and the last one is the <samp>content</samp> data.  (The long data chunks were broken into multiple lines for readability, consult the code repositories for actual test vectors.)</p>
<p id="rfc.section.4.4.3.p.3">Here is the transfer object for the second event:</p>
<pre>
83                                      # array(3)
   58 7C                                # bytes(124)
      85D9041A5821020113F4DD8C981D1D87BC7F46CF86E8E7B0FB774F839
      930DD38D6A13F69D9693DD9041A582101AED3DAB65CE9E0D6C50D46FC
      EFFB552296ED21B6E0B537A6A0184575CE8F5CBD021A5D3F888183011
      6D9041A58210395CCA4FA7B24ABC6049683E716292B00C49509BE147A
      A024C06286BD9B7DBDA8
   58 40                                # bytes(64)
      AFE8658C6F5229951DB4DB82F62E9D930B6CD8F155C5D47586556012E
      D9C560487C05AAE58A2B66970CBAB666E43890DEB01F33E5281B0F9C7
      E22F68A437AF09
   56                                   # bytes(22)
      7B2269223A312C2274797065223A2274657374227D0A

</pre>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#code-and-roll-out" id="code-and-roll-out">Code and roll out</a>
</h1>
<p id="rfc.section.5.p.1">The current work-in-progress code, licensed under MIT is available for <a href="http://cryptbox.mindeco.de/ssb/gabbygrove">Go</a> and <a href="https://github.com/cryptix/js-gabbygrove">javascript</a> to show interoperability and that signature verification and content hashing works as expected. <a href="https://github.com/cryptoscope/ssb">go-ssb</a> also has integrated in it&#8217;s native sbot, testing against <a href="https://github.com/cryptoscope/ssb/blob/f6960c92e333b219709755a04b03c61500685adb/tests/ggdemo/index.js">a demo plugin</a> for <a href="https://github.com/ssbc/ssb-server">ssb-server</a>.</p>
<p id="rfc.section.5.p.2">One open question would be how to get this into EBT while also supporting the classical/legacy way of encoding feeds.  For replication of single feeds we can use the established stream command <samp>createHistoryStream</samp> which can pick the correct transfer encoding based on the passed feed reference.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#remarks" id="remarks">Remarks</a>
</h1>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#alternative-encodings" id="alternative-encodings">Alternative Encodings</a>
</h1>
<p id="rfc.section.6.1.p.1">Having worked with CBOR and Protocol Buffers, CBOR feels like the better tool for the job.  Especially since it could also be used for encoding of the <samp>content</samp> itself where Protocol Buffers would require shared schemas for all types.</p>
<p id="rfc.section.6.1.p.2">Possible alternatives:</p>
<p></p>

<ul>
<li>Cap&#8217;n Proto: seemed like a bit bleeding edge.</li>
<li>MessgePack: my reading of Appendix E, it&#8217;s quite stable but extension mechanism is in a dead end.</li>
<li>Protocol Buffers: pretty steep dependency, generated code, schema only interesting for event entries, not higher levels of the stack</li>
</ul>
<p><a href="https://tools.ietf.org/html/rfc7049#appendix-E">Appendix E of CBORs RFC</a> also shows how CBOR compares to ASN.1/DER/BER, BSON and UBJSON.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#deletion-requests" id="deletion-requests">Deletion requests</a>
</h1>
<p id="rfc.section.6.2.p.1">I believe we should leave this out of the spec and just give way for clients to drop content as wanted. Tuning replication rules with signed deletions or what ever can be done orthogonal if the chain/feed format allows validation with missing content.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#size-benefits" id="size-benefits">Size benefits</a>
</h1>
<p id="rfc.section.6.3.p.1">This cuts down the amount of transmitted bytes considerably. As an example, a <em>old</em> contact message weighs in at roughly 434 bytes (JSON without whitespace, sequence in the hundreds range). Encoding a contact message with this, results in 289 bytes, 119 of which are still JSON. This overhead is small for longer posts but still wanted to mention it. The main driver of this reduction is the binary encoding of the references and being able to omit the field names. Converting content to a binary encoding would reduce it further but as stated above would require strict schemas for every type.</p>
<h1 id="rfc.section.6.4">
<a href="#rfc.section.6.4">6.4.</a> <a href="#how-long-lived-this-will-be" id="how-long-lived-this-will-be">How long lived this will be?</a>
</h1>
<p id="rfc.section.6.4.p.1">I <em>think</em> this is a solid format but wouldn&#8217;t mind to be superseded by something else once it surfaces. As a migration path, I&#8217;d suggest we double down on <samp>sameAs</samp>.  The <em>simplest</em>  case of it would be terminating one feed and starting a new one, while logically appending one to the other for higher levels of the protocol stack.  The implications for indexing things like the friend graph and how to end feeds in the old format show that this needs to be covered in a separate spec.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#addressed-comments-from-protochain" id="addressed-comments-from-protochain">Addressed comments from ProtoChain</a>
</h1>
<p id="rfc.section.7.p.1">Apart from choosing another library for marshalling bytes this proposal changed the name of a couple of things.</p>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#event-2" id="event-2">Event</a>
</h1>
<p id="rfc.section.7.1.p.1">as <a href="ssb://@AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519">@cft</a> mentioned in <a href="ssb://%pXxsQeOENZ/M9vYAlf1+99tqvTY8WtVwSkOEfQddV2o=.sha256">his first comment</a>, <em>Message</em> and <em>Meta</em> were not easy to speak and reason about. &#8220;What includes what?&#8221; wasn&#8217;t easy enough to answer. The <em>Message</em> was conceptually redundant as well since it&#8217;s fields can be in the <samp>transfer</samp> structure as well to achieve the same results. Which is why there is just a single concept for this called <samp>event</samp>.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#content-type" id="content-type">&#8220;Content Type&#8221;</a>
</h1>
<p id="rfc.section.7.2.p.1">Was not only wrong because it is already a named concept on the higher level (type:contact, type:post, etc.) but also because it is not specific enough.  This field deals with the <em>encoding</em> of the content and thus should be named as such.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#comments-addressed-since-the-first-off-chain-content-proposal" id="comments-addressed-since-the-first-off-chain-content-proposal">Comments addressed since the first &#8220;off-chain content&#8221; proposal</a>
</h1>
<p id="rfc.section.8.p.1">Remarks this proposal addresses over <a href="ssb://%LrMcs9tqgOMLPGv6mN5Z7YYxRQ8qn0JRhVi++OyOvQo=.sha256">the first Off-chain content proposal</a>:</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#incrementing-on-a-broken-format" id="incrementing-on-a-broken-format">incrementing on a broken format</a>
</h1>
<p id="rfc.section.8.1.p.1">The main idea of the first proposal was to add off-chain content without overhauling the verification scheme.  We got numerous comments on this, the gist being that we tried to hard, improving something that should be deprecated altogether.</p>
<p id="rfc.section.8.1.p.2">Therefore we chose a clean slate approach with a new encoding scheme. This comes with the downside of requiring multiple supported <em>feed formats</em> in the stack. Personally I think this is good though as it will pave the way for other formats, like bamboo, as well.</p>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#the-use-of-muxrpc-specific-features-for-transmissionreplication" id="the-use-of-muxrpc-specific-features-for-transmissionreplication">The use of MUXRPC specific features for transmission/replication</a>
</h1>
<p id="rfc.section.8.2.p.1">The idea to transmit content and metadata as two <a href="https://github.com/ssbc/muxrpc">MUXRPC</a> frames was my idea. It seems sensible/practical because it fitted into the existing stack but I see now that it tried to much to fit into the existing way and hid a dependency along the way.</p>
<p id="rfc.section.8.2.p.2">This is why the <samp>transfer</samp> structure definition has a dedicated field for <samp>content</samp> which can be set to <samp>null</samp> to indicate unavailability.</p>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC7049">[RFC7049]</b></td>
<td class="top">
<a>Bormann, C.</a> and <a>P. Hoffman</a>, "<a href="https://tools.ietf.org/html/rfc7049">Concise Binary Object Representation (CBOR)</a>", RFC 7049, DOI 10.17487/RFC7049, October 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8032">[RFC8032]</b></td>
<td class="top">
<a>Josefsson, S.</a> and <a>I. Liusvaara</a>, "<a href="https://tools.ietf.org/html/rfc8032">Edwards-Curve Digital Signature Algorithm (EdDSA)</a>", RFC 8032, DOI 10.17487/RFC8032, January 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8259">[RFC8259]</b></td>
<td class="top">
<a>Bray, T.</a>, "<a href="https://tools.ietf.org/html/rfc8259">The JavaScript Object Notation (JSON) Data Interchange Format</a>", STD 90, RFC 8259, DOI 10.17487/RFC8259, December 2017.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Henry Florenz Bubert</span> 
	  <span class="n hidden">
		<span class="family-name">cryptix</span>
	  </span>
	</span>
	<span class="org vcardline">SSBC</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:cryptix@riseup.net">cryptix@riseup.net</a></span>

  </address>
</div>

</body>
</html>
