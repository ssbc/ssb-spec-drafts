



Secure Scuttlebutt Working Group                               H. Bubert
SSB-Draft      ssb:@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519
Intended status: Informational                             July 29, 2019
Expires: January 30, 2020


                  GabbyGrove (CBOR based Feed Format)
                      draft-ssb-core-gabbygrove-00

Abstract

   This document defines a new binary format for append-only feeds as
   used by Secure-Scuttlebutt.  That is, defining the bytes that are
   used for computing the cryptographic signatures and hashes that form
   a feed.  It strives to do two things: be easier to implement then the
   current scheme.  Hence, it uses CBOR [1] [RFC7049] to encode the
   logical values that describe each entry.  Secondly, it only reference
   content by hash on the feed entry to enable content deletion without
   breaking verification of the feed.

Status of This Memo

   SSB-Drafts are working documents of the Secure Scuttlebutt community.
   Note that other groups may also distribute working documents as SSB-
   Drafts.

   SSB-Drafts are draft documents valid for a maximum of six months and
   may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use SSB-Drafts as reference material or
   to cite them other than as "work in progress."

   This SSB-Draft will expire on January 30, 2020.

Copyright Notice

   Copyright (c) 2019 SSB Council and the persons identified as the
   document authors.  All rights reserved.


Table of Contents

   1.  Gabby Grove . . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.1.  incrementing on a broken format . . . . . . . . . . . . .   2
     1.2.  The use of muxprc specific features for
           transmission/replication  . . . . . . . . . . . . . . . .   3
   2.  Rationale . . . . . . . . . . . . . . . . . . . . . . . . . .   3
     2.1.  Keeping the timestamp on the message  . . . . . . . . . .   3
     2.2.  Having the author on the message  . . . . . . . . . . . .   3



Bubert                  Expires January 30, 2020                [Page 1]

SSB-Draft                   DRAFT GabbyGrove                   July 2019


     2.3.  Only encoding the content . . . . . . . . . . . . . . . .   3
   3.  Definitions for SSB . . . . . . . . . . . . . . . . . . . . .   4
     3.1.  Event . . . . . . . . . . . . . . . . . . . . . . . . . .   4
     3.2.  Transfer  . . . . . . . . . . . . . . . . . . . . . . . .   4
     3.3.  Cipherlinks . . . . . . . . . . . . . . . . . . . . . . .   5
   4.  CBOR  . . . . . . . . . . . . . . . . . . . . . . . . . . . .   6
     4.1.  Basics  . . . . . . . . . . . . . . . . . . . . . . . . .   6
     4.2.  Canonical encoding  . . . . . . . . . . . . . . . . . . .   7
     4.3.  Extensability . . . . . . . . . . . . . . . . . . . . . .   8
     4.4.  CDDL  . . . . . . . . . . . . . . . . . . . . . . . . . .   8
   5.  Code and roll out . . . . . . . . . . . . . . . . . . . . . .   9
   6.  Remarks . . . . . . . . . . . . . . . . . . . . . . . . . . .  10
     6.1.  Alternative Encodings . . . . . . . . . . . . . . . . . .  10
     6.2.  Deletion requests . . . . . . . . . . . . . . . . . . . .  10
     6.3.  Size benefits . . . . . . . . . . . . . . . . . . . . . .  10
     6.4.  How long lived this will be?  . . . . . . . . . . . . . .  10
   7.  Adressed comments from ProtoChain . . . . . . . . . . . . . .  11
     7.1.  Event . . . . . . . . . . . . . . . . . . . . . . . . . .  11
     7.2.  "Content Type"  . . . . . . . . . . . . . . . . . . . . .  11
     7.3.  Algorithmic choices . . . . . . . . . . . . . . . . . . .  11
   8.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  11
     8.1.  Informative References  . . . . . . . . . . . . . . . . .  11
     8.2.  URIs  . . . . . . . . . . . . . . . . . . . . . . . . . .  12
   Appendix A.  CDDL Spec v1 . . . . . . . . . . . . . . . . . . . .  12
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  13

1.  Gabby Grove

   This is the revised version of the initial ProtoChain proposal [2].
   The main difference to _ProtoChain_ is that _Gabby Grove_ uses CBOR
   instead of Protocol Buffers.

   I propose the "ggfeed-v1" suffix as a default feed reference and
   "ggmsg-v1" for messages.

   Remarks this proposal addresses over the first Off-chain content
   proposal [3]:

1.1.  incrementing on a broken format

   The main idea of the first proposal was to add offchain-content
   without overhauling the verification scheme.  We got numerous
   comments on this, the gist being that we tried to hard, improving
   something that should be deprecated altogether.

   Therefore we chose a clean slate approach with a new encoding scheme.
   This comes with the downside of requiring multiple supported _feed




Bubert                  Expires January 30, 2020                [Page 2]

SSB-Draft                   DRAFT GabbyGrove                   July 2019


   formats_ in the stack.  Personally I think this is good though as it
   will pave the way for other formats, like bamboo, as well.

1.2.  The use of muxprc specific features for transmission/replication

   The idea to transmit content and metadata as two muxrpc frames was my
   idea.  It seems sensible/practical because it fitted into the
   existing stack but I see now that it tried to much to fit into the
   existing way and hid a dependency along the way.

   This is why we have the "transfer" message definition which has two
   fields.  One for the message, which should be required and one field
   for the content, which can be omitted.

2.  Rationale

   While this is would introduce radical new ways of doing things, like
   requiring CBOR for encoding and supporting multiple feed formats, it
   also makes concessions to how things are currently.  In a sense this
   proposal should be seen as an overhaul of the current scheme, only
   adding offchain capabilities.  Let me elaborate on two of them which
   cater to this point specifically:

2.1.  Keeping the timestamp on the message

   In principle, the timestamp is an application concern.  Some message
   types could omit it and it could ne considered _cleaner_ to move them
   up into the content of the types that want/need them.  We recognize
   however that it would stir up problems for existing applications and
   this is something we are not interested in.

2.2.  Having the author on the message

   A similar argument could be made for the author of a message.  In the
   current design the author never changes over the lifetime of a feed,
   so why have it on each and every message?  Especially if you
   replicate one feed at a time it seems wasteful, since the author is
   already known.

   @dominic made a pretty good security argument here [4].  It should
   always be known which key-pair created a signature and thus having it
   reduces ambiguity and possible backdoors.

2.3.  Only encoding the content

   This format would only encode the metadata as CBOR, leaving the
   _user_ to encode their content as they see fit.  Since we don't want
   to cause problems for applications, we suggest keeping the "content"



Bubert                  Expires January 30, 2020                [Page 3]

SSB-Draft                   DRAFT GabbyGrove                   July 2019


   portion in JSON.  This should allow for messages to be mapped full
   JSON objects which look just like regular messages so that they can
   be consumed by applications without any change.

   For upgrades and more advance uses we added an "encoding enum" that
   defines known values for arbitrary data ("0"), JSON ("1") and CBOR
   ("2").  CBOR _should_ be good at converting it's values to JSON for
   integration and backwards compatability.

3.  Definitions for SSB

3.1.  Event

   A single entry on an feed with this format is called an event
   (formerly also known as Message).  It contains a fixed number of
   fields:

   o  A cipherlink to the "previous" one, null only on the first
      message.

   o  The ed25519 public key of the "author", also encoded as a
      cipherlink.

   o  The "sequence" number of the entry as an unsigned integer.
      Increasing by 1 each entry, starting with 1.

   o  An unsigned integer describing a "timestamp".  Like in node/
      javascript, unix epoch timestamp but in milliseconds.

   o  "content": a group of three fields:

      *  "hash" as a cipherlink

      *  "size" as a uint16, increasing the maximum message size to 64k.

      *  "encoding" enumeration of three possible values.

3.2.  Transfer

   The next needed message structure is "transfer".  It consists of
   three byte arrays:

   o  The encoded bytes of an _Event_, here called "eventData".

   o  "signature": 64 bytes, to be verified against the "author"s public
      key from the event.

   o  the optional "content": a maximum of 64k bytes.



Bubert                  Expires January 30, 2020                [Page 4]

SSB-Draft                   DRAFT GabbyGrove                   July 2019


   To validate a message, the receiver just takes the "eventData" and
   the "signature" and passes them to the cryptographic function that
   does the validation.  In this case, edwards25519 as defined in
   [RFC8032], also known as Ed25519 from Networking and Cryptography
   library (NaCL) [5].

   If present, hashing the "content" needs to compute the same the as
   the "content.hash" field on the event.  If it should be ommited, it
   needs to be set to null (primitive 22 or "0xf6" in CBOR) to keep the
   array it's contained in of length three.

   The Hash of a signed event (and the "previous" field of the next
   event) is the blak2b-256 of "eventData" and "signature" bytes
   concataneted.

3.3.  Cipherlinks

   The hashes and public key references are not base64 encoded readable
   ASCII strings but are binary encoded.

   In this first version we don't plan to support many formats, which is
   why I decided against something like IPFS Multihash, which supports
   every hash function under the sun.

   Currently there are these different reference types:

   o  "0x01": references to gabby grove formatted feeds (ED25519 Public
      Key, 32bytes of data)

   o  "0x02": gabby grove signed event hashes (such as "previous"),
      using blake2b-256 (32bytes of data)

   o  "0x03": "content.hash" also using blake2b-256 (32bytes of data)

   o  "0x04": "SSB v1", legacy / old feed reference (ED25519 Public Key,
      32bytes of data)

   o  "0x05": SHA256 message hashes as used by legacy ssb

   o  "0x06": SHA256 binary blob hashes as used by legacy ssb

   Only 1 to 3 are valid on gabby grove event fields.  4 to 6 are
   intended to encode cipherlinks in CBOR encoded content when
   referencing feeds in the legacy format.  I'm relativly certain and
   hopefull this will be revised and extended but it feels like a good
   starting point.  They all should be convertable to and from the
   base64 encoded ASCII references we currently use in JSON.




Bubert                  Expires January 30, 2020                [Page 5]

SSB-Draft                   DRAFT GabbyGrove                   July 2019


   We add one byte as prefix to those bytes, making all references
   33bytes long.

4.  CBOR

4.1.  Basics

   If you never worked with CBOR, I suggest checking out it's website
   [6] and the definitions in [RFC7049]).  Similar to JSON it is a _self
   describing_ format.  Which means, bytes of it can be translated to
   logical, typed values without the need for a schema definition.

   What helped me a lot as well to understand it better were the cbor-
   diag utilities [7] (or the the playground at cbor.me [8] with the
   same features).  With it, you can translate between bytes and the
   diagnostic noation (defined in section 6 of it's RFC).  Roughly
   speaking you can use JSON like literals as diagnostic input for
   "diag2pretty.rb" (or the left side of the playground):

   {
     "type": "test",
     "count": 123,
     "true": false,
     "link": null
   }

   which outputs a hexadecimal, indented and commented representation
   with type annotations:

   A4               # map(4)
      64            # text(4)
         74797065   # "type"
      64            # text(4)
         74657374   # "test"
      65            # text(5)
         636F756E74 # "count"
      18 7B         # unsigned(123)
      64            # text(4)
         74727565   # "true"
      F4            # primitive(20)
      64            # text(4)
         6C696E6B   # "link"
      F6            # primitive(22)

   The comments tell us the types and values again.  The first line says
   _A4 means the following is a map with 3 entries_.  Maps are key-value
   pairs, so we get three pairs of first the name (or key) of the pair
   and then the value.  Next to signed and unsigned number types it also



Bubert                  Expires January 30, 2020                [Page 6]

SSB-Draft                   DRAFT GabbyGrove                   July 2019


   has predefined primitives for "true", "false" and "null".  Notice
   that the keys are also typed (_text of len N_).

   Let's compare it to an array of the same values, without the keys:

   ["test", 123, false, null]

   results in

   84             # array(4)
      64          # text(4)
         74657374 # "test"
      18 7B       # unsigned(123)
      F4          # primitive(20)
      F6          # primitive(22)

   This results in 10 encoded bytes.  The map example needs 31, in
   comparison.

   Encoding the same well-defined objects as maps over and over again
   comes with a lot of overhead and redundant description of the field
   names.

   This was my main concern in comparisson to Protocol Buffers.  A self-
   describing format isn't that usefull here since the fields don't
   change.  As shown above, the size overhead of encoding structs as
   maps can be mitigated by encoding them as arrays instead.

4.2.  Canonical encoding

   We _could_ define the first field of a "transfer" as an _event_
   itself instead of opagque bytes but I want to make canonical encoding
   on this level of the protocol optional.  Meaning: if you can re-
   produce the same "eventData" from an de-coded stored "Event", go
   ahead.  Butt, diverging one bit from the original "eventData" means
   that signature verification and hash comparison will fail.  Over all
   this seems like an potentially instable and divergent way of
   exchanging feeds, producing incorret references if implemetations
   incorrectly consume forked heads as actual messages.

   However, as an experiment, implementers are advised to use the
   canonical CBOR suggestions defined in Section 3.9 [9].  Since we only
   use bytes, integers and tags for our strucutres we can ignore the
   suggestions for map keys and floats.

   Potentially, a canonical encoding would allow for skipping certain
   fields on the transport layer.  "author", "sequence" and even




Bubert                  Expires January 30, 2020                [Page 7]

SSB-Draft                   DRAFT GabbyGrove                   July 2019


   "previous" could be filled in by the receiver themselvs to produce
   the full "eventData".

   It would also free implementors on the question of how to store
   events.  It's unclear to the author if this amounts to a worth-while
   endevor tompare to just storing the bytes of the "transfer".

4.3.  Extensability

   CBOR allows for augmenting the types of it's values with an additonal
   numeric tag.  These are hints for the de- and encoders to treat some
   type of values differently.

   This kind of extensability through type tags seems usefull for SSB,
   especially if we ever change away from JSON as the content encoding.
   With it, we can explicitly mark cipherlinks as such, for instance.

   Another option would be to explicitly tag the whole "transfer", which
   is otherwise _just_ an array with three entries, and state how the
   signature was computed by the author's key-pair referenced inside the
   "event".

   See Section 2.4 of CBORs RFC [10] for more.

4.4.  CDDL

   Here is an exceprt of the format specfication in _Concise data
   definition language (CDDL)_ [RFC8610] which describes the "event" and
   "content" objects.  The full file is attached as Appendix A.






















Bubert                  Expires January 30, 2020                [Page 8]

SSB-Draft                   DRAFT GabbyGrove                   July 2019


   event = [
     previous: cipherlink,
     author: cipherlink,
     sequence: uint,
     timestamp: uint,
     content,
   ]

   content = [
       hash: cipherlink,
       size: uint16,
       encoding: contentEncoding,
   ]

   ; 33 bytes, tagged with major type 6, number 1050
   cipherlink = #6.1050(bytes .size 33)

   ; possible values for content encoding are 0, 1 and 2
   contentEncoding = 0..2

   ; 16-bit unsigned int, equivalent to 0..65536
   uint16 = uint .size 2

   It allows for more detailed description and definition of valid
   objects and seems like an interesting tool to define supported types
   and messages for higher levels of SSB as well.

5.  Code and roll out

   the current work-in-progress repository can be found here [11].

   It experiments with Go and javascript interoperability and shows that
   signature verification and content hashing works as expected.

   Integration into go-ssb or the javascript stack is pending on review
   comments.

   One open question would be how to get this into EBT while also
   supporting the classical/legacy way of encoding messages.  For
   classical replication I'd suggest a new rpc stream command, similar
   to "createHistoryStream" which sends "transfer" encoded messages one
   by one.

   The upcoming verse app will use this format, possibly only with
   encoding content as json for now.






Bubert                  Expires January 30, 2020                [Page 9]

SSB-Draft                   DRAFT GabbyGrove                   July 2019


6.  Remarks

6.1.  Alternative Encodings

   Having worked with CBOR and Protocol Buffers, CBOR feels like the
   better tool for the job.  Especially since it could also be used for
   encoding of the "content" itself where Protocol Buffers would require
   shared schemas for all types.

   Possible alternatives:

   o  Cap'n Proto: seemed like a bit bleeding edge.

   o  MessgePack: my reading of Appendix E, it's quite stable but
      extension mechanism is in a dead end.

   o  Protocol Buffers: pretty steap dependency, generated code, schema
      only interesting for event entries, not higher levels of the stack

   Appendix E.  (Comparison of Other Binary Formats to CBOR's Design
   Objectives) [12] also shows how CBOR compares to ASN.1/DER/BER, BSON
   and UBJSON.

6.2.  Deletion requests

   I believe we should leave this out of the spec and just give way for
   clients to drop content as wanted.  Tuning replication rules with
   signed deletions or what ever can be done orthogonal if the chain/
   feed format allows validation with missing content.

6.3.  Size benefits

   This cuts down the amount of transmitted bytes considerably.  As an
   example, a _old_ contact message clocks in at roughly 434 bytes (JSON
   without whitespace, sequence in the hundreds range).  Encoding a
   contact message with this, results in 289 bytes, 119 of which are
   still JSON.  This overhead is small for longer posts but still wanted
   to mention it.  The main driver of this reduction is the binary
   encoding of the references and being able to omit the field names.
   Converting content to a binary encoding would reduce it further but
   as stated above would require strict schemas for every type.

6.4.  How long lived this will be?

   I _think_ this is a solid format but wouldn't mind to be superseded
   by something else once it surfaces.  As a migration path, I'd suggest
   we double down on "sameAs".  The _simplest_ case of it would be
   terminating one feed and starting a new one, while logically



Bubert                  Expires January 30, 2020               [Page 10]

SSB-Draft                   DRAFT GabbyGrove                   July 2019


   appending one to the other for higher levels of the protocol stack.
   The implications for indexing things like the friend graph and how to
   end feeds in the old format show that this needs to be coverted in a
   seperate spec.

7.  Adressed comments from ProtoChain

   Apart from chosing another library to CBOR for encoding the bytes
   this proposal changed the name of a couple of things.

7.1.  Event

   as @cft [13] mentioned in his first comment [14], _Message_ and
   _Meta_ were not easy to speak and reason about.  "What includes
   what?" wasn't easy enough to answer.  The _Message_ was conceptually
   redundant as well since it's fields can be in the _Transfer_
   structure as well to achive the same results.  Which is why there is
   just a single concept for this called _Event_.

7.2.  "Content Type"

   Was not only wrong because it is already a named concept on the
   higher level (type:contact, type:post, etc.) but also because it is
   not specific enough.  This field deals with the _encoding_ of the
   content and thus should be named as such.

7.3.  Algorithmic choices

   It tries to be more explicit with it's cryptographic algorithms.

8.  References

8.1.  Informative References

   [RFC7049]  Bormann, C. and P. Hoffman, "Concise Binary Object
              Representation (CBOR)", RFC 7049, DOI 10.17487/RFC7049,
              October 2013, <https://www.rfc-editor.org/info/rfc7049>.

   [RFC8032]  Josefsson, S. and I. Liusvaara, "Edwards-Curve Digital
              Signature Algorithm (EdDSA)", RFC 8032,
              DOI 10.17487/RFC8032, January 2017,
              <https://www.rfc-editor.org/info/rfc8032>.

   [RFC8610]  Birkholz, H., Vigano, C., and C. Bormann, "Concise Data
              Definition Language (CDDL): A Notational Convention to
              Express Concise Binary Object Representation (CBOR) and
              JSON Data Structures", RFC 8610, DOI 10.17487/RFC8610,
              June 2019, <https://www.rfc-editor.org/info/rfc8610>.



Bubert                  Expires January 30, 2020               [Page 11]

SSB-Draft                   DRAFT GabbyGrove                   July 2019


8.2.  URIs

   [1] https://cbor.io

   [2] %3ATKLKIHdM+beamr1dqoO2Jd6BC7oW5zj0ygLvmDsEc=.sha256

   [3] %LrMcs9tqgOMLPGv6mN5Z7YYxRQ8qn0JRhVi++OyOvQo=.sha256

   [4] %1AsqTRxdVrbfypC69W7uWbMClQteNNnnl3ohzbpu3Xw=.sha256

   [5] https://nacl.cr.yp.to/

   [6] https://cbor.io

   [7] https://github.com/cabo/cbor-diag

   [8] https://cbor.me

   [9] https://tools.ietf.org/html/rfc7049#section-3.9

   [10] https://tools.ietf.org/html/rfc7049#section-2.4

   [11] http://cryptbox.mindeco.de/ssb/gabbygrove

   [12] https://tools.ietf.org/html/rfc7049#appendix-E

   [13] @AiBJDta+4boyh2USNGwIagH/wKjeruTcDX2Aj1r/haM=.ed25519

   [14] %pXxsQeOENZ/M9vYAlf1+99tqvTY8WtVwSkOEfQddV2o=.sha256

Appendix A.  CDDL Spec v1

   ; this document uses the Concise data definition language (CDDL)
   ; https://tools.ietf.org/html/rfc8610

   ; it describes the data strucutres that are used
   ; by the gabby grove feed format for secure-scuttlebutt (ssb)
   ; feeds are single author/writer and they don't fork.
   ; the use of hash functions to address previous entries,
   ; turns them into an append-only linked-list that can't be alterd.

   ; a single entry on a feed (formerly also known as message)
   event = [
     previous: cipherlink,
     author: cipherlink,
     sequence: uint,
     timestamp: uint,
     content,



Bubert                  Expires January 30, 2020               [Page 12]

SSB-Draft                   DRAFT GabbyGrove                   July 2019


   ]

   content = [
       hash: cipherlink,
       size: uint16,
       encoding: contentEncoding,
   ]

   ; 33 bytes, tagged with major type 6, number 1050
   ; this is used to indicate the cryptographic references
   cipherlink = #6.1050(bytes .size 33)
   ; See section 2.4 and iana registry for already defined tags
   ; https://tools.ietf.org/html/rfc7049#section-2.4
   ; https://www.iana.org/assignments/cbor-tags/cbor-tags.xhtml#tags

   ; possible values for content encoding are 0, 1 and 2
   ; 0 means _arbitrary bytes_ (like an private message, image or tar)
   ; 1 means json
   ; 2 means cbor
   contentEncoding = 0..2

   ; 16-bit unsigned int, equivalent to 0..65536
   uint16 = uint .size 2

   ; transfer describes a signed event with the actual content
   transfer = [
     eventData: bytes,         ; event encoded as bytes
     signature: signature,     ; the signature
     ? contentData: bytes,     ; the actual bytes of the content
   ]

   ; we _could_ define the first field of a transfer as an _event_
   ; but I want to make canonical encoding on this level
   ; only optional but not a requirement as output

   ; v1 only support Ed25519 curves.
   ; These signatures are always 64 bytes long.
   signature = bytes .size 64

Author's Address

   Henry Florenz Bubert
   ssb:@p13zSAiOpguI9nsawkGijsnMfWmFd5rlUNpzekEE+vI=.ed25519

   Email: cryptix@riseup.net






Bubert                  Expires January 30, 2020               [Page 13]
